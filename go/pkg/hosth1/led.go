// Support for LED-only configs (kinematics: none) in connect-phase compilation.
//
// Copyright (C) 2026  Klipper Go Migration
//
// This file may be distributed under the terms of the GNU GPLv3 license.

package hosth1

import (
	"fmt"
	"hash/crc32"
	"strings"

	"klipper-go-migration/pkg/protocol"
)

// CompileLEDConnectPhase compiles the connect-phase MCU command stream for
// LED-only configurations (kinematics: none with LED sections).
//
// Handles: [led], [neopixel], [dotstar], [pca9533], [pca9632]
// OID layout (matching Python):
// oid=0: neopixel
// oid=1: SPI for dotstar
// oid=2: I2C for pca9533
// oid=3: I2C (software) for pca9632
// oid=4: digital_out for [led] PWM
func CompileLEDConnectPhase(cfgPath string, dict *protocol.Dictionary) ([]string, error) {
	cfg, err := loadConfig(cfgPath)
	if err != nil {
		return nil, err
	}
	clockFreq, err := dictConfigFloat(dict, "CLOCK_FREQ")
	if err != nil {
		return nil, err
	}

	// Fixed OID layout to match Python expected output
	const (
		oidNeopixel = 0
		oidSPI      = 1
		oidI2C1     = 2
		oidI2C2     = 3
		oidPWM      = 4
		oidCount    = 5
	)

	var configCmds []string

	// Python order: SPI config, I2C configs, then PWM LED, then neopixel
	// 1. config_spi_without_cs (for dotstar)
	dotstarSec, hasDotstar := cfg.sections["dotstar dled"]
	if hasDotstar {
		configCmds = append(configCmds,
			fmt.Sprintf("config_spi_without_cs oid=%d", oidSPI),
		)
	}

	// 2. config_i2c for pca9533 and pca9632
	_, hasPca9533 := cfg.sections["pca9533 p5led"]
	if hasPca9533 {
		configCmds = append(configCmds,
			fmt.Sprintf("config_i2c oid=%d", oidI2C1),
		)
	}

	pca9632Sec, hasPca9632 := cfg.sections["pca9632 p6led"]
	if hasPca9632 {
		configCmds = append(configCmds,
			fmt.Sprintf("config_i2c oid=%d", oidI2C2),
		)
	}

	// 3. config_digital_out + set_digital_out_pwm_cycle for PWM LED
	ledSec, hasLed := cfg.sections["led lled"]
	if hasLed {
		redPin := strings.TrimSpace(ledSec["red_pin"])
		if redPin != "" {
			// PWM cycle time is typically 0.01s (10ms) = 160000 ticks at 16MHz
			cycleTicks := int(clockFreq * 0.01)
			configCmds = append(configCmds,
				fmt.Sprintf("config_digital_out oid=%d pin=%s value=0 default_value=0 max_duration=0", oidPWM, redPin),
				fmt.Sprintf("set_digital_out_pwm_cycle oid=%d cycle_ticks=%d", oidPWM, cycleTicks),
			)
		}
	}

	// 4. config_neopixel
	neopixelSec, hasNeopixel := cfg.sections["neopixel nled"]
	if hasNeopixel {
		pin := strings.TrimSpace(neopixelSec["pin"])
		chainCount := 4 // default from config
		if cc := strings.TrimSpace(neopixelSec["chain_count"]); cc != "" {
			fmt.Sscanf(cc, "%d", &chainCount)
		}
		// Each neopixel has 3 bytes (GRB), data_size = chain_count * 3
		dataSize := chainCount * 3
		// bit_max_ticks for WS2812 at 16MHz: ~64 ticks (4us)
		// reset_min_ticks: ~800 ticks (50us)
		configCmds = append(configCmds,
			fmt.Sprintf("config_neopixel oid=%d pin=%s data_size=%d bit_max_ticks=64 reset_min_ticks=800", oidNeopixel, pin, dataSize),
		)
	}

	// Prepend allocate_oids
	withAllocate := append([]string{fmt.Sprintf("allocate_oids count=%d", oidCount)}, configCmds...)

	// Add bus configuration commands in order
	// 5. spi_set_sw_bus for dotstar
	if hasDotstar {
		dataPin := strings.TrimSpace(dotstarSec["data_pin"])
		clockPin := strings.TrimSpace(dotstarSec["clock_pin"])
		// Mode 0, pulse_ticks=32
		withAllocate = append(withAllocate,
			fmt.Sprintf("spi_set_sw_bus oid=%d miso_pin=%s mosi_pin=%s sclk_pin=%s mode=0 pulse_ticks=32", oidSPI, dataPin, dataPin, clockPin),
		)
	}

	// 6. i2c_set_bus for pca9533 (hardware I2C)
	if hasPca9533 {
		// Default address 98 (0x62), rate 100000
		withAllocate = append(withAllocate,
			fmt.Sprintf("i2c_set_bus oid=%d i2c_bus=twi rate=100000 address=98", oidI2C1),
		)
	}

	// 7. i2c_set_sw_bus for pca9632 (software I2C)
	if hasPca9632 {
		sclPin := strings.TrimSpace(pca9632Sec["i2c_software_scl_pin"])
		sdaPin := strings.TrimSpace(pca9632Sec["i2c_software_sda_pin"])
		// Default address 98 (0x62), pulse_ticks=80
		withAllocate = append(withAllocate,
			fmt.Sprintf("i2c_set_sw_bus oid=%d scl_pin=%s sda_pin=%s pulse_ticks=80 address=98", oidI2C2, sclPin, sdaPin),
		)
	}

	// Compute CRC
	crcText := strings.Join(withAllocate, "\n")
	crc := crc32.ChecksumIEEE([]byte(crcText))

	// Build final output with config commands only
	// Runtime initialization commands (queue_digital_out, i2c_write, neopixel_update, spi_send)
	// are generated by the sensor-only runtime during initialization
	out := make([]string, 0, len(withAllocate)+1)
	out = append(out, withAllocate...)
	out = append(out, fmt.Sprintf("finalize_config crc=%d", crc))

	return out, nil
}

// formatHexByte formats a single byte as \xNN for use in Python byte strings.
func formatHexByte(b byte) string {
	if b >= 32 && b < 127 && b != '\'' && b != '\\' {
		return string(b)
	}
	return fmt.Sprintf("\\x%02x", b)
}
